"use strict";(()=>{var e={};e.id=7600,e.ids=[7600],e.modules={3524:e=>{e.exports=require("@prisma/client")},399:e=>{e.exports=require("next/dist/compiled/next-server/app-page.runtime.prod.js")},517:e=>{e.exports=require("next/dist/compiled/next-server/app-route.runtime.prod.js")},4770:e=>{e.exports=require("crypto")},7273:(e,t,r)=>{r.r(t),r.d(t,{originalPathname:()=>N,patchFetch:()=>x,requestAsyncStorage:()=>h,routeModule:()=>v,serverHooks:()=>w,staticGenerationAsyncStorage:()=>f});var n={};r.r(n),r.d(n,{POST:()=>c,PUT:()=>m});var s=r(9303),a=r(8716),i=r(670),o=r(7070),u=r(3524),l=r(4770),d=r.n(l);let p=new u.PrismaClient;async function c(e){try{let{userId:t,email:n}=await e.json();if(!t&&!n)return o.NextResponse.json({error:"User ID or email required"},{status:400});let s=await p.users.findUnique({where:t?{id:t}:{email:n}});if(!s)return o.NextResponse.json({error:"User not found"},{status:404});let a=d().randomBytes(32).toString("hex"),i=new Date(Date.now()+6048e5),u=await p.users.update({where:{id:s.id},data:{inviteToken:a,inviteExpiry:i,updatedAt:new Date},select:{id:!0,email:!0,firstName:!0,lastName:!0,inviteToken:!0,inviteExpiry:!0}}),{EmailService:l}=await r.e(2323).then(r.bind(r,2323));return await l.sendInvitationEmail(s.email,`${s.firstName} ${s.lastName}`,a)||console.warn(`[INVITATION] Failed to send invitation email to ${s.email}`),console.log(`[INVITATION] Token generated for ${s.email}: ${a}`),console.log(`[INVITATION] Invitation URL: ${process.env.NEXT_PUBLIC_BASE_URL||"http://localhost:3001"}/auth/accept-invite?token=${a}`),o.NextResponse.json({message:"Invitation sent successfully",user:u})}catch(e){return console.error("Failed to send invitation:",e),o.NextResponse.json({error:"Failed to send invitation"},{status:500})}}async function m(e){try{let{userIds:t}=await e.json();if(!t||!Array.isArray(t)||0===t.length)return o.NextResponse.json({error:"User IDs array required"},{status:400});let r=[],n=[];for(let e of t)try{let t=d().randomBytes(32).toString("hex"),n=new Date(Date.now()+6048e5),s=await p.users.update({where:{id:e},data:{inviteToken:t,inviteExpiry:n,updatedAt:new Date},select:{id:!0,email:!0,firstName:!0,lastName:!0,inviteToken:!0}});r.push(s),console.log(`[BULK_INVITATION] Token generated for ${s.email}: ${t}`)}catch(t){n.push({userId:e,error:t instanceof Error?t.message:"Unknown error"})}return o.NextResponse.json({message:`Bulk invitation completed. ${r.length} successful, ${n.length} failed.`,successful:r,failed:n})}catch(e){return console.error("Failed to send bulk invitations:",e),o.NextResponse.json({error:"Failed to send bulk invitations"},{status:500})}}let v=new s.AppRouteRouteModule({definition:{kind:a.x.APP_ROUTE,page:"/api/admin/users/invite/route",pathname:"/api/admin/users/invite",filename:"route",bundlePath:"app/api/admin/users/invite/route"},resolvedPagePath:"/Users/cory/Documents/Cloudy-Work/applications/jw-attendant-scheduler/app/api/admin/users/invite/route.ts",nextConfigOutput:"",userland:n}),{requestAsyncStorage:h,staticGenerationAsyncStorage:f,serverHooks:w}=v,N="/api/admin/users/invite/route";function x(){return(0,i.patchFetch)({serverHooks:w,staticGenerationAsyncStorage:f})}}};var t=require("../../../../../webpack-runtime.js");t.C(e);var r=e=>t(t.s=e),n=t.X(0,[9276,5972],()=>r(7273));module.exports=n})();